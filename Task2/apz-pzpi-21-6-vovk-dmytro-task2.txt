3 ІНЖЕНЕРНІ РІШЕННЯ
	3.1 Структура та технології проєкту

Технології для створення серверної частини було обрано з урахуванням потреб системи та власного досвіду роботи. Тому вибір пав на фреймворк ASP.NET Core. І оскільки система повинна бути масштабованою, було прийняте рішення використовувати RabbitMQ для обміну повідомленнями між екземплярами програми. У результаті, при проєктуванні системи був використаний патерн DDD (Domain-Driven Design) як головний і Command для обробки повідомлень від RabbitMQ та WebSocket клієнтів. 
У проєкті максимально використовується “Dependency Injection”, що реалізується фреймворком ASP.NET. Всі сервіси та обробники, що реалізовані у програмі, є зареєстрованими у системі сервісів від ASP.NET.
У  ролі сховища даних було обрано MongoDB, тому що у ній є вбудовані інструменти для роботи з координатами на сфері, що є дуже важливою складовою для програмної системи в цілому.
Також для зменшення навантаження на базу даних, було прийняте рішення використовувати Redis для кешування часто використовуваних даних. Більше деталей на UML діаграмі розгортання(див. рис. 3.1).
Взаємодія між клієнтами та сервером відбувається за допомогою різних каналів, таких як HTTP REST API, SignalR та WebSocket. Для веб та мобільних користувачів передбачене використання HTTP REST API та SignalR, а для переносних пристроїв користувача та роботів - WebSocket та частково HTTP REST API.



Рисунок 3.1 - UML діаграма розгортання.

3.2 Специфікація API

Таблиця 1 – Специфікація HTTP REST API серверної частини системи

Сутність
Метод
Посилання
Опис
Авторизація
POST
/api/auth/login
Авторизація користувача
GET
/api/auth/device/token
Генерує токен доступу для портативного пристрою користувача
/api/auth/device/refresh
Оновлює згенерований токен портативного пристрою користувача


Продовження таблиці 1

Сутність
Метод
Посилання
Опис
Підтвердження
GET
/api/confirm
Використовується для підтвердження дії
Групи
GET
/api/group
Отримати перелік груп
/api/group/my
Отримати перелік грум у яких знаходиться користувач
/api/group/{id}
Інформація про групу
/api/group/{id}/detail
Детальна інформація про групу
/api/group/{id}/members
Перелік учасників групи
POST
/api/group
Створити групу
/api/group/{groupId}/members/{userId}
Додати користувача до групи
/api/group/{groupId}/admin/{userId}
Додати користувача як адміністратора
PUT
/api/group/{groupId}
Оновлення інформації про групу
/api/group/{groupId}/area
Оновлення зони відповідальності групи
DELETE
/api/group/{id}
Видалити групу
/api/group/{groupId}/members/{userId}
Вигнати користувача з групи
/api/group/{groupId}/admin/{userId}
Видалити користувача з переліку адміністраторів

Продовження таблиці 1

Сутність
Метод
Посилання
Опис
Роботи
GET
/api/robots
Перелік роботів
/api/robots/{id}
Інформація про робота
POST
/api/robots
Створити робота
PUT
/api/robots/{id}
Оновити інформацію про робота
/api/robots/self/location
Оновлення позиція робота
/api/robots/{id}/status
Оновити статус робота
/api/robots/{id}/accessLevel
Оновити рівень доступу робота
/api/robots/{id}/scanRadius
Оновити радіус сканування робота
DELETE
/api/robots/{id}
Видалити робота
Користувачі
GET
/api/users
Отримати перелік користувачів


/api/users/self
Отримати інформацію про себе


/api/users/{id}
Отримати інформацію про користувача


POST
/api/users
Створити користувача

Продовження таблиці 1

Сутність
Метод
Посилання
Опис
Користувачі
POST
/api/users/activate
Активувати зареєстрований обліковий запис користувача
PUT
/api/users/{id}
Оновити інформацію про користувача
/api/users/{id}/resetPassword
Запит на скидання пароля користувача
/api/users/self/password
Оновлення власного пароля користувача
/api/users/self/email
Оновлення власної адреси електронної пошти користувача
/api/users/{id}/permissions
Оновлення прав користувача
/api/users/{id}/status
Оновлення статусу користувача
/api/users/{id}/accessLevel
Оновлення рівня доступу користувача
/api/users/{id}/scanRadius
Оновлення радіуса сканування користувача
DELETE
/api/users/{id}
Видалення користувача

Таблиця 2 – Специфікація WebSocket серверної частини системи

Шлях
Команда
Опис
/connect/device
updateLocation
Оновлення геолокації користувача



3.3 Реалізація механізму публікації даних у RabbitMQ

Робота із RabbitMQ поділяється на дві частини: відправка повідомлень та отримання й обробка повідомлень. 
Для роботи із RabbitMQ було створено сервіс, який успадкований від інтерфейсу “IRabbitMqConnection” (див. розділ А.1 у додатку А), що представлений в одному екземплярі через використання Dependensy Injanction (далі - DI) в ASP.NET та зареєстрований за допомогою функції “AddSingleton”.
Щоб відправляти повідомлення, було створено сервіс-фабрику що реалізує інтерфейс “IMessagePublisherFactory” (див. розділ А.2 у додатку А), за допомогою якої можна легше створювати канати для комунікації, вона прибирає повторюваний код. Своєю чергою, канали комунікації представлені інтерфейсом “IMessagePublisher” (див. розділ А.3 у додатку А). Використаний шаблон проєктування “Factory”.
У випадку із каналом для обміну повідомленнями, що пов’язані із WebSocket, було також створено окремий сервіс, що існує у єдиному екземплярі під назвою “WebSocketMessagePublisher” (див. розділ А.4 у додатку А) він також реалізує інтерфейс “IWebSocketMessagePublisher” (див. розділ А.5 у додатку А). 
Завдяки цього, ми отримали можливість працювати із єдиним екземпляром сервісу “WebSocketMessagePublisher” (див. розділ А.4 у додатку А), який завжди тримає відкритим єдиний екземпляр “IMessagePublisher” (див. розділ А.3 у додатку А) для надсилання повідомлень у RabbitMQ на вказаний канал.

3.4 Реалізація механізму обробки повідомлень від RabbitMQ

Для обробки повідомлень від RabbitMQ було реалізовано “Hosted Service” під назвою “RabbitMqConsumerService” (див. розділ А.6 у додатку А). Цей сервіс отримує перелік зареєстрованих, у системі DI, обробників та налаштовує прослуховування відповідних каналів.
Самі обробники представленні у вигляді класів, що реалізують інтерфейс “IConsumerHandler” (див. розділ А.7 у додатку А). Використаний шаблон проєктування “Command”.

3.5 Реалізація механізму обробки повідомлень від RabbitMQ у темі про WebSocket з’єднання

Для обробки повідомлень у темі “websocket” (назва за замовчуванням, задана у файлі конфігурацій), було створено відповідний обробник “RabbitMqWebSocketHandler” (див. розділ А.8 у додатку А), що реалізує інтерфейс “IConsumerHandler” (див. розділ А.7 у додатку А). При ініціалізації цього обробника, завантажуються всі сервіси, що реалізують інтерфейс “IRabbitMqWebSocketHandler” (див. розділ А.9 у додатку А). Коли приходить повідомлення від RabbitMQ у вказану тему, обробник читає заголовок під назвою “function”, що дає змогу зрозуміти, яку реалізацію необхідно викликати.

3.6 Конфігурування

Для гнучкості роботи, система має можливість конфігурування, яке переставлене у вигляді файлу у форматі JSON. Доступ до конфігурацій відбувається за допомогою функціоналу ASP.NET та представлення параметрів конфігураційного файлу у вигляді класів, частина яких додана до DI як Singleton сервіси, що дозволяє швидко та просто отримати доступу до конфігурацій програми із будь-якої точки.

3.7 Механізм оновлення геолокації користувача

Для оновлення геолокації, користувач повинен мати свій IoT пристрій. Своєю чергою, цей пристрій передає власну геолокацію у систему.
Токен доступу до системи, пристрій оновлює за 2 хв до закінчення дії старого токену.
Процес оновлення геолокації продемостровано на діаграмі діяльності (див. рис. 3.2).



Рисунок 3.2 - UML діаграма діяльності оновлення геолокації

3.8 Робота з даними

Роботу з даними можна поділити на 3 етапи: запит, обробка, репозиторій. Запит користувача на дані, викликає його обробку у сервісі, який своєю чергою звертається до репозиторію що взаємодіє з базою даних. Кешування даних відбувається на рівні сервісу.
Для роботи репозиторіїв, було створено інтерфейс “IRepository<T>” (див. розділ А.10 у додатку А) там де “T” це клас, що повинен реалізовувати інтерфейс “IIdentifier” (див. розділ А.11 у додатку А). Також, для уникнення дублювання коду, створено абстрактний клас “BaseMongoDbRepository<CollectionT>”, який реалізує інтерфейс “IRepository<T>” (див. розділ А.10 у додатку А). Від цього абстрактного класу успадковуються усі інші репозиторії.

3.9 Механізм роботи системи дозволів користувача

Кожен користувач має рівень доступу та перелік дозволених дій, які він може робити відносно користувачів із меншим рівнем доступу. Перелік дозволів представлений у вигляді об'єкта “ClientPermissions” (див. розділ А.12 у додатку А) що реалізує інтерфейс “IPermissionQuery” (див. розділ А.13 у додатку А). Також об'єкт “ClientPermissions” (див. розділ А.12 у додатку А) має інші властивості, такі як “Users”, “Robots” та “Groups” які мають перелік логічних (bool) властивостей.
Кожна властивість, що має відношення до дозволів, має атрибут “PermissionAttribute” (див. розділ А.14 у додатку А).
Для перевірки наявності дозволу, використовується функція “Has” класу “ClientPermissions” (див. розділ А.12 у додатку А), вона поверне виключення, якщо функція перевірки поверне брехню (false), в іншому випадку, “Has” повертає інтерфейс “IPermissionQuery” (див. розділ А.13 у додатку А). 
При оновленні дозволів користувач не може надати більше дозволів ніж має сам.

3.10 Створення IoT пристрою

Для створення IoT пристрою, користувач повинен мати відповідний дозвіл у системі. Створення пристрою відбувається шліхом генерації токена доступу на 30 хв (за замовчуванням, вказано у конфігураціях). Після чого цей токен завантажується у пристрій і використовуватись ним.
Коли підходить час закінчення дії токена, пристрій робить запит на оновлення, який генерує новий токен для нього. Функція генерації токенів виглядає наступним чином (див. розділ А.15 у додатку А).

3.11 Отримання переліку користувачів у вказаному радіусі

Для роботи з координатами використовуються вбудовані інструменти MongoDB. Їх використання прописане у функціях “GetNearRobots” (див. розділ А.16 у додатку А) та “GetNearUsers” (див. розділ А.17 у додатку А), відповідно репозиторіїв “RobotRepository” та “UserRepository”.

3.12 Використання SіgnalR

Для швидкого обміну даними між клієнтом та сервером було обрано SignalR, його використання обумовлене можливістю групування клієнтів та відносно простим викликом функцій із передачею параметрів.
При встановленні з’єднання, користувач додається у групу, назвою якої є його ідентифікатор (див. розділ А.18 у додатку А), що дозволяє працювати із різними з’єднаннями одного користувача, як з одним. Також користувач додається у групи, назви яких дорівнюють ідентифікаторам груп системи, у яких є цей користувач.
Після розірвання з’єднання, користувач буде видалений з усіх груп (див. розділ А.19 у додатку А).
